<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>State and Lifecycel</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
    //Handling Events 时间处理

      // react事件以驼峰命名 
      // React events are named using camelCase, rather than lowercase.
      // JSX传函数而不是传字符串 
      // With JSX you pass a function as the event handler, rather than a string.
      // <button onClick={activateLasers}>
      //   Activate Lasers
      // </button>

      // return false 不能阻止默认行为 而是用preventDefault
      // function ActionLink() {
      //   function handleClick(e) {
      //     e.preventDefault();
      //     console.log('The link was clicked.');
      //   }
      //   return (
      //     <a href="#" onClick={handleClick}>
      //       Click me
      //     </a>
      //   );
      // }
      // e is a synthetic event 
      // e是一个封装跨浏览器时间对象

      // 添加事件（初始化时添加？）:just provide a listener when the element is initially rendered.
      // class Toggle extends React.Component {
      //   constructor(props) {
      //     super(props);
      //     this.state = { isToggleOn: true };

      //     // just provide a listener when the element is initially rendered.
      //     // 严格模式下需手动绑定this 否则是undefined
      //     this.handleClick = this.handleClick.bind(this);
      //   }

      //   handleClick(){
      //     this.setState(prevState => ({
      //       isToggleOn: !prevState.isToggleOn
      //     }));
      //   }

      //   render(){
      //     return (
      //       <button onClick={this.handleClick}>
      //         {this.state.isToggleOn ? 'ON' : 'OFF'}
      //       </button>
      //     );
      //   }
      //   // render和constructor似乎都自带this定位
      // }
      // ReactDOM.render(
      //   <Toggle />,
      //   document.getElementById('root')
      // );

      // 关于React/严格模式下的this绑定
      // 1. public class fields syntax 公共类域语法？
      // *********************这儿没太明白
      // class LoggingButton extends React.Component {
      //   // This syntax ensures `this` is bound within handleClick.
      //   // Warning: this is *experimental* syntax.
      //   handleClick = () => {
      //     console.log('this is:', this);
      //   }
      //   render(){
      //     return (
      //       <button onClick={this.handleClick}>
      //         Click me
      //       </button>
      //     )
      //   }
      // }
      // ReactDOM.render(
      //   <LoggingButton />,
      //   document.getElementById('root')
      // )
      // 2.箭头函数
      // class LoggingButton extends React.Component {
      //   handleClick() {
      //     console.log('this is:', this);
      //   }
      //   render(){
      //     // This syntax ensures `this` is bound within handleClick
      //     // **************************这儿实际上也没太明白
      //     return (
      //       <button onClick={(e) => this.handleClick(e)}>
      //  它这儿箭头函数也是个指代性调用
      //         Click me
      //       </button>
      //     )
      //   }
      // }
      // ReactDOM.render(
      //   <LoggingButton />,
      //   document.getElementById('root')
      // )
      // The problem with this syntax is that a different callback is created each time the LoggingButton renders. 
      // In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do an extra re-rendering. 
      // We generally recommend binding in the constructor or using the class fields syntax, to avoid this sort of performance problem.
      // 这种模式会在每个组件中生产独立回调函数 如改回调又以prop形式传给下级组件 可能会触发下级组件的重复渲染
      // 官方推荐把this绑定在constructor或者应用类域语法

      // Passing Arguments to Event Handlers
      // 向事件回调传参 （额外传参）
      // <button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
      // <button onClick={this.deleteRow.bind(this, id)}>Delete Rom</button>
      //以上两种写法等效
      // In both cases, the e argument representing the React event will be passed as a second argument after the ID.
      //  With an arrow function, we have to pass it explicitly, but with bind any further arguments are automatically forwarded.
      // 箭头函数需要显式传e 而bind方式不用

      // 彩蛋:关于 fun.bind(thisArg[, arg1[, arg2[, ...]]])
      // thisArg
      // 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。
      // arg1, arg2, ...
      // 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。
      

      


    </script>
    <!--
      Note: this page is a great way to try React but it's not suitable for production.
      It slowly compiles JSX with Babel in the browser and uses a large development build of React.

      To set up a production-ready React build environment, follow these instructions:
      * https://reactjs.org/docs/add-react-to-a-new-app.html
      * https://reactjs.org/docs/add-react-to-an-existing-app.html

      You can also use React without JSX, in which case you can remove Babel:
      * https://reactjs.org/docs/react-without-jsx.html
      * https://reactjs.org/docs/cdn-links.html
    -->
  </body>
</html>